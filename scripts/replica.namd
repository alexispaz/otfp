#!/usr/bin/tclsh

replicaBarrier

# Boltzman constant
set kB_kcm 0.001987191

# This should be set for each particular system taking in account a high
# probability configuration
set zprob 3.2

# Initialize

set NUMREP [numReplicas]
if { $num_replicas != $NUMREP } {error "restart with wrong number of replicas"}
set loc [myReplica]

if {[info exists restart_root]} { #restart
  set restart_root [format $restart_root $loc]
  source $restart_root.tcl
} else {
  set i_job 0 
  set i_run 0
  set i_step 0
  if {[info exists first_timestep]} {
    set i_step $first_timestep
  }

  # index is the replica number (asociated with a particular temp)
  set replica(index) $loc

  # index.a and index.b is only defined in order to compute the acceptance
  # always using the lower temperature. Note that this is nos required for the
  # algorithm, but it will allows to keep an statistics of exechange ratios
  # (the exechange 3-4 is stored in 3)
  set replica(index.a) $loc
  set replica(index.b) $loc


  # loc is the procesor where the replica runs.
  # Note that, since a replica moves in order to avoid swap configurations, the
  # loc of the neighboors replicas could be any number while their index has
  # always one unit of difference
  set replica(loc.a) $loc
  set replica(loc.b) $loc
  set replica(exchanges_attempted) 0
  set replica(exchanges_accepted) 0

  # Initially, a map of the replica netweork will be:
  #
  #           a         b       a           b
  # temp  300     330      360       ...       600
  # index 0 <----> 1 <----> 2 <----> ... <----> n
  # loc   0        1        2        ...        n
  #
  # if myreplica is odd, left replica is "a" and right replica is "b".
  # if myreplica is even, left replica is "b" and right replica is "a"
  #
  # "a" and "b" interachange sets are taken per turn. So in each turn, if 0
  # swap with 1, 2 can swap with 3 safety. In all the cases, only left replica
  # will compute the metropoly crietrion while right replica will send the
  # needed information.
  #
  # After a nnumber of swaps, if we keep the temperature order, the new scheme
  # could be
  #
  #           a         b       a           b
  # temp  330     450      600       ...       260
  # index 1 <----> 4 <----> n <----> ... <----> 2
  # loc   0        1        2        ...        n
  #
  # The replica (asociated with index) is changin the location, however, is
  # important to know that loc is used to communicate trough mpi, is the
  # processor, never change for this script, beside the location of the
  # neighbor repplcas can change.
   
  # Set replica on the right as replica a or b
  # if { $loc+1 < $NUMREP } {
  #   if { $loc % 2 == 0 } {
  #     set i a
  #   } else {
  #     set i b
  #   }
  #   set replica(loc.$i)   $replica(loc.r)  
  #   set replica(index.$i) $replica(index.r)
  # }

  # # Set left replica as replica a or b
  # if { $loc+1 > 0 } {
  #   if { $loc % 2 == 0 } {
  #     set i b
  #   } else {
  #     set i a
  #   }
  #   set replica(loc.$i)   [expr $loc-1]
  #   set replica(index.$i) [expr $loc-1]
  # }

  if { $loc % 2 == 0 && $loc+1 < $NUMREP } {
    set replica(loc.a) [expr $loc+1]
    set replica(index.a) [expr $loc+1]
  }
  if { $loc % 2 == 1 && $loc > 0 } {
    set replica(loc.a) [expr $loc-1]
    set replica(index.a) [expr $loc-1]
  }

  if { $loc % 2 == 1 && $loc+1 < $NUMREP } {
    set replica(loc.b) [expr $loc+1]
    set replica(index.b) [expr $loc+1]
  }
  if { $loc % 2 == 0 && $loc > 0 } {
    set replica(loc.b) [expr $loc-1]
    set replica(index.b) [expr $loc-1]
  }

}

set job_output_root "${output_root}job$i_job"
firsttimestep $i_step


# Set real temperature 
proc replica_temp { i } {
  global num_replicas min_temp max_temp
  if ($num_replicas==1) {return $min_temp}; #Allow 1 replica for debug purpouse
  return [format "%.2f" [expr ($min_temp * \
         exp( log(1.0*$max_temp/$min_temp)*(1.0*$i/($num_replicas-1)) ) )]]
}

set replica(temperature)   [replica_temp $loc]
set replica(temperature.a) [replica_temp $replica(loc.a)]
set replica(temperature.b) [replica_temp $replica(loc.b)]
set replica(beta)          [expr 1.0/($replica(temperature)*$kB_kcm)]
set replica(beta.a)        [expr 1.0/($replica(temperature.a)*$kB_kcm)]
set replica(beta.b)        [expr 1.0/($replica(temperature.b)*$kB_kcm)]



# Set ficticius temperature 
proc replica_auxtemp { x t } {
  global kB_kcm

  # The boost in TAMD is controled by alpha=beta-auxbeta with alpha between
  # (0,beta) for a positive boost. 0 is the lower boost and beta the higher.
  # From this we get: auxT=T/(1.-alpha kB T).
  #
  # Defining c=1/(1.-alpha kB T) and x=auxTmin/Tmin, some options are:
  #
  # 1- A decreasing boost with T ( alpha=(1-1/x)/(kBT) ):
  set c $x
  
  # 2- A constant boost for all T ( alpha=(1-1/x)/(kBTmin) ):
  #    this form needed that x<1/(1-Tmin/Tmax), because if Tmax is large enough
  #    then no auxTmax will exist to keep acomplish with a certain alpha.
  # global min_temp
  # global max_temp
  # if [expr $x>1./(1.-$min_temp/$max_temp)] {error "An infinity auxTmax is obtained"}
  # set c [expr 1./(1.-(1.-1./$x.)*$t/($min_temp) )]

  return [expr $t*$c]
}

set replica(auxtemp)   [replica_auxtemp 10. $replica(temperature)]
set replica(auxtemp.a) [replica_auxtemp 10. $replica(temperature.a)]
set replica(auxtemp.b) [replica_auxtemp 10. $replica(temperature.b)]
set replica(auxbeta)   [expr 1.0/($replica(auxtemp)*$kB_kcm)]
set replica(auxbeta.a) [expr 1.0/($replica(auxtemp.a)*$kB_kcm)]
set replica(auxbeta.b) [expr 1.0/($replica(auxtemp.b)*$kB_kcm)]


# Delta Betas
set dbeta(a) [expr $replica(beta.a)-$replica(beta)]
set dbeta(b) [expr $replica(beta.b)-$replica(beta)]
set replica(dbeta)  [expr $replica(auxbeta)-$replica(beta)]

# Save variables
proc save_callback {labels values} {
  global saved_labels saved_values
  set saved_labels $labels
  set saved_values $values
}
callback save_callback

proc save_array {} {
  global saved_labels saved_values saved_array
  foreach label $saved_labels value $saved_values {
    set saved_array($label) $value
  }
}



# Read NAMD config 

# seed variable is also used by OTFP
set seed [expr int(0*srand(int(100000*rand()) + 100*$loc) + 100000*rand() + 1)]
seed $seed

# Initial temperature
set NEWTEMP $replica(temperature)
langevinTemp $NEWTEMP

# Initial state
if {$i_run} { 
  # restart
  bincoordinates $restart_root.coor
  binvelocities $restart_root.vel
  extendedSystem $restart_root.xsc
} else {
  temperature $NEWTEMP
}

# Other config
source $namd_config_file

# Log  of exchanges
set history_file [open [format "$job_output_root.history" $loc] "w"]
fconfigure $history_file -buffering line


# Main loop
while {$i_run < $num_runs} {

  # After the first run, the global scope of the tclforces is accesible 
  # here. Then, variables like "chapeau" can be used now.
  run $steps_per_run
  
  # Save array for ...?
  save_array

  incr i_step $steps_per_run


  # if { ($i_run+1) % $runs_per_addchapeaus == 0 } {
  #   set chserial [chapeau_serialize $chape(0.address)]
  #   puts stderr "Befor: I'm $loc, writing chapeau 0: $chserial"
  # }
   
  # Do I have to add all the chapeaus?
  if { ($i_run+1) % $runs_per_addchapeaus == 0 } {

    if { $loc == 0 } {puts stderr "EXCHANGE_CHAPEAUS at $i_step"}

    # To do it in parallel. Each processor can add the chapeaus of a
    # different temperature. The adition is carry on after all the
    # comunications ends. 
   
    # First, all process comunicate each other the chapeaus
    for {set i 0} {$i < $NUMREP} {incr i} {
      if { $loc == $i } {
        # I get all the contributions
        for {set j 0} {$j < $NUMREP} {incr j} {
          if { $i == $j } continue
          set chserials($i.$j) [replicaRecv $j]
        }
      } else {
        # Send partial statistics to the center replica
        set chserial [chapeau_serialize $chape($i.address)]
        replicaSend $chserial $i
      }
    }
    
    # Then, all process perform the adition
    for {set i 0} {$i < $NUMREP} {incr i} {
      if { $loc == $i } continue
      chapeau_addserialized $chape($loc.address) $chserials($loc.$i)
    }

    # Finally, the comunication backward of the results
    for {set i 0} {$i < $NUMREP} {incr i} {
      if { $loc == $i } {
        # Send the full statistics to the other replicas
        set chserial [chapeau_serialize $chape($i.address)]
        for {set j 0} {$j < $NUMREP} {incr j} {
          if { $i == $j } continue
          replicaSend $chserial $j
        }
      } else {
        # Set full replica statistic variables and clean the partial ones
        set chserial [replicaRecv $i]
        chapeau_setserialized $chape($i.address) $chserial
      }
    }

  }

  # if { ($i_run+1) % $runs_per_addchapeaus == 0 } {
  #   set chserial [chapeau_serialize $chape(0.address)]
  #   puts stderr "After: I'm $loc, writing chapeau 0: $chserial"
  # }

  # Get replica info from NAMD
  set TEMP $saved_array(TEMP)
  set POTENTIAL [expr $saved_array(TOTAL) - $saved_array(KINETIC)]

  # Get replica info from TAMD
  set r  1
  set chapeau $chape($replica(index).address)
  set z  [ restr_getz $restr($r.address)  ]
  set f  [ chapeau_evalf $chapeau $z  ]
  set u  [ restr_getu $restr($r.address)  ]
  
  # This should be set for each particular system taking in account a high
  # probability configuration
  # set zprob 3.2
  set fref  [ chapeau_evalf $chapeau $zprob ]

  puts $history_file "$i_step   $replica(index)   $NEWTEMP   $TEMP   $POTENTIAL   $f $fref $u"
  
  # Select a or b replica
  if { $i_run % 2 == 0 } {
    set swap a; set other b
  } else {
    set swap b; set other a
  }

  # Aceptance computed only for the replica with lower temperature. Note that this criteria
  # allows to accumulate exechange information not like other criteria (e.g.
  # replica located at the left)
  set doswap 0
  if { $replica(index) < $replica(index.$swap) } {

    # Compute Delta U term
    set pot2  [replicaRecv $replica(loc.$swap)]
    set delta [expr $dbeta($swap) * ($pot2-$POTENTIAL)]
     
    # Compute Delta Uk term
    set u2  [replicaRecv $replica(loc.$swap)]
    set delta [expr $delta + $dbeta($swap) * ($u2 - $u)]
     
    # Compute Delta Free Energy of this replica
    set z2 [replicaSendrecv $z $replica(loc.$swap) $replica(loc.$swap)]
    set f2  [ chapeau_evalf $chapeau $z2 ]
    set delta [expr $delta - $replica(dbeta) * ($f2 - $f)]
      
    # Compute Delta Free Energy of the swap replica
    set aux [ replicaRecv $replica(loc.$swap) ]
    set delta [expr $delta + $aux ]

    # # Metropoli creiterion and send results
    # puts stderr " $replica(index) exp($delta)"
    set prob [expr exp($delta)]
    set doswap [expr $delta > 0. || $prob > rand()]
    replicaSend $doswap $replica(loc.$swap)

    if { $doswap } {
      puts stderr "EXCHANGE_ACCEPT $i_run, $replica(index) $replica(index.$swap) $replica(temperature) $replica(temperature.$swap) $prob"
      incr replica(exchanges_accepted)
    }

    incr replica(exchanges_attempted)
  }

  if { $replica(index) > $replica(index.$swap) } {

    replicaSend $POTENTIAL $replica(loc.$swap)
    replicaSend $u $replica(loc.$swap)

    set z2 [replicaSendrecv $z $replica(loc.$swap) $replica(loc.$swap)]
    set f2  [ chapeau_evalf $chapeau $z2 ]

    set delta [expr $replica(dbeta) * ($f2 - $f)]
    replicaSend $delta $replica(loc.$swap)

    set doswap [replicaRecv $replica(loc.$swap)]
  }

  # About the update of variable other
  #
  # Think in this escenario, being the present replica in loc 5
  #    loc=9    |  loc=5    |  loc=3    
  #   .$other=5 | .$other=9 | .$other=8  
  # If replica 5 had swap with 3
  #    loc=9    |  loc=5    |  loc=3    
  #   .$other=3 | .$other=8 | .$other=9
  # If replica 9 had swap with X
  #    loc=9    |  loc=5    |  loc=3    
  #   .$other=Z | .$other=X | .$other=8
  # If both things happend
  #    loc=9    |  loc=5    |  loc=3    
  #   .$other=Z | .$other=8 | .$other=X
  
  # Let newOtherOther=5 or change it to 3 if doswap occurs
  set newOtherOther $loc
  if { $doswap } {
    set newOtherOther $replica(loc.$swap)
    set replica(loc.$swap) $loc
  }

  # On send change loc(9).other to newOtherOther
  # On recive update loc(5).other to the newOtherOther coming from loc(9).other  
  set replica(loc.$other) [replicaSendrecv $newOtherOther $replica(loc.$other) $replica(loc.$other)]

  if { $doswap } {

    # The entire replica array is sent. Take care of keep it minimal.
    set OLDTEMP $replica(temperature)
    array set replica [replicaSendrecv [array get replica] $newOtherOther $newOtherOther]
    set NEWTEMP $replica(temperature)

    # Set new temperature and rescale velocities
    rescalevels [expr sqrt(1.0*$NEWTEMP/$OLDTEMP)]
    langevinTemp $NEWTEMP

    # Update the auxiliary temperature of the OTFP restraint
    set restr($r.temp) $replica(auxtemp)
    restr_UpdateTamdOpt $restr($r.address) $restr($r.g) [expr $kB_kcm*$restr($r.temp)] $restr($r.dt)

    # update the chapeau ids
    set restr($r.chid) $replica(index)
    restr_set_rchid $restr($r.address) $ds $replica(index)
    set chapeau $chape($replica(index).address)
  }

  incr i_run

  # Restart
  if { $i_run % $runs_per_restart == 0 || $i_run == $num_runs } {  

    # All the processor should dump the local state
    set restart_root "$job_output_root.restart$i_run"
    output [format $restart_root $loc]
    set rfile [open [format "$restart_root.tcl" $loc] "w"]
    puts $rfile [list array set replica [array get replica]]
    close $rfile
    # TODO: Dump chapeau state

    # Let processor 1 to write to the restart the global info
    replicaBarrier
    if { $loc == 0 } {
      set rfile [open [format "$restart_root.tcl" ""] "w"]
      puts $rfile [list set i_job [expr $i_job + 1]]
      puts $rfile [list set i_run $i_run]
      puts $rfile [list set i_step $i_step]
      puts $rfile [list set restart_root $restart_root]
      close $rfile
      if [info exists old_restart_root] {
        set oldroot [format $old_restart_root ""]
        file delete $oldroot.tcl
      }
    }
    replicaBarrier

    # Remove old restart local state files
    if [info exists old_restart_root] {
      set oldroot [format $old_restart_root $loc]
      file delete $oldroot.tcl
      file delete $oldroot.coor
      file delete $oldroot.vel
      file delete $oldroot.xsc
    }
    set old_restart_root $restart_root
  }
}


# Output statistics on exchange...
set attempts $replica(exchanges_attempted)
if $attempts {

  #...between this replica and the replica in the right
  if { $replica(index.a) > $replica(index) } {
    set swap a
  } else {
    set swap b
  }

  set temp $replica(temperature)
  set temp2 $replica(temperature.$swap)
  set accepts $replica(exchanges_accepted)
  set ratio [expr 1.0*$accepts/$attempts]
  puts stderr "EXCHANGE_RATIO $replica(index) $replica(index.$swap) $temp $temp2 $accepts $attempts $ratio"
}

replicaBarrier

