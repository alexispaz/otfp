#pragma once
#ifndef CVS_H
#define CVS_H

#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "measurements.h"

// Cross reference with cfacv.h
struct DataSpace;  
typedef struct DATASPACESTRUCT DataSpace;
// this is needed because the dataspace
// I guess that the coordinates should be a pointer of arrays in the cv structure
// in order to give independence to this module
#include "cfacv.h"
 
// collective variable structure
typedef struct CVSTRUCT {
  int typ;       // collective variable type
  int nC;        // count of atoms or atom-groups that contribute to this CV
  int * ind;     // indices in the atom/atom-group array generated by
                 // tclforces of the atoms that contribute to this CV
  double val;    // value of the CV
  double ** gr;  // cartesian gradients of this CV wrt contributing
                 // atom/atom-groups: gr[atom/atom-group][x|y|z]
                
                
  //pointer to function that calculate the value of the cv
  int (*calc)(struct CVSTRUCT * self,  DataSpace * ds);
                
} cvStruct;

// headers
int cv_getityp ( char * typ );
int cv_dimension ( cvStruct * c );
char * cv_getstyp ( int ityp );
cvStruct * New_cvStruct ( int typ, int nC, int * ind );
 
int calccv_x     ( cvStruct * c, DataSpace * ds );
int calccv_y     ( cvStruct * c, DataSpace * ds );
int calccv_z     ( cvStruct * c, DataSpace * ds );
int calccv_s     ( cvStruct * c, DataSpace * ds );
int calccv_bond  ( cvStruct * c, DataSpace * ds );
int calccv_dihed ( cvStruct * c, DataSpace * ds );
int calccv_angle ( cvStruct * c, DataSpace * ds );
int calccv_bilayerpoint ( cvStruct * c, DataSpace * ds );
           
#endif
