#pragma once
#ifndef CVS_H
#define CVS_H

#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "measurements.h"

// collective variable structure
typedef struct cv {
  int typ;       // collective variable type
  int nC;        // count of atoms or atom-groups that contribute to this CV
  int * ind;     // indices in the atom/atom-group array generated by
                 // tclforces of the atoms that contribute to this CV
  double val;    // value of the CV
  double ** gr;  // cartesian gradients of this CV wrt contributing
                 // atom/atom-groups: gr[atom/atom-group][x|y|z]
   
  // Use to apply a force to the CV
  double f;
  double u;
  
  // boundaries
  double min;
  double max;
  double half_domain;
  double boundk;
  int (*boundFunc)(struct cv * self);

  // This array is used for some kind of cv like RMSD.
  // Most common CV types will lead ref as a null pointer in general.  A better
  // way for this scenario should be using derived types but C does not handle
  // very well inheritance and polymorphism. 
  double ** ref;
  double ** ref2;
  double refmod;

  FILE * ofp;
  int outputFreq;
  int boutput;
 
  //pointer to function that calculate the value of the cv
  int (*calc)(struct cv * self,  double ** R );
  
} cv;
     
// headers
cv * cv_init ( char * typ, int nC, int * ind, 
    double zmin, double zmax, char * boundstr, double boundk, char * outfile, int outputFreq);

int cv_getityp ( char * typ );
char * cv_getstyp ( int ityp );
 
int calccv_line  ( cv * c, double ** R );
int calccv_rmsd  ( cv * c, double ** R );
int calccv_cogx  ( cv * c, double ** R );
int calccv_cogy  ( cv * c, double ** R );
int calccv_cogz  ( cv * c, double ** R );
int calccv_x     ( cv * c, double ** R );
int calccv_y     ( cv * c, double ** R );
int calccv_z     ( cv * c, double ** R );
int calccv_s     ( cv * c, double ** R );
int calccv_bond  ( cv * c, double ** R );
int calccv_dihed ( cv * c, double ** R );
int calccv_angle ( cv * c, double ** R );
int calccv_zsd_circle ( cv * c, double ** R );
int calccv_zsd_xrange ( cv * c, double ** R );
int calccv_zsd_ring ( cv * c, double ** R );
int set_zsd_circle ( double x,double y, double xy, double s  ); 
int set_zsd_ring ( double x,double y, double r1, double r2, double s  ); 
double fcut(double r,double r1,double r2,double dfcut);
           
double cdf(double x);

// Boundaries Functions
int cv_SoftUpperWall ( cv * c );
int cv_SoftLowerWall ( cv * c );
int cv_SoftWalls ( cv * c );
int cv_nada ( cv * c );
         

double * cv_access_ref ( cv * c, int i );
double * cv_access_ref2 ( cv * c, int i );

void cv_output ( cv * c );

  
int set_line (cv * c);
#endif
